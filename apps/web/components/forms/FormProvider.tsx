'use client';

import React from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useState } from 'react';

import type { FormMetadata } from '@workspace/types';
import { NetworkErrorAnalyzer, RetryHandler } from './NetworkErrorHandler';

interface FormContextType {
  currentMetadata: FormMetadata | null;
  setCurrentMetadata: (metadata: FormMetadata) => void;
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
  error: string | null;
  setError: (error: string | null) => void;
  clearError: () => void;
}

const FormContext = React.createContext<FormContextType | undefined>(undefined);

export function useFormContext() {
  const context = React.useContext(FormContext);
  if (context === undefined) {
    throw new Error('useFormContext must be used within a FormProvider');
  }
  return context;
}

interface FormProviderProps {
  children: React.ReactNode;
}

export function FormProvider({ children }: FormProviderProps) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 30 * 1000, // 30 seconds
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  const [currentMetadata, setCurrentMetadata] = React.useState<FormMetadata | null>(null);
  const [isLoading, setIsLoading] = React.useState(false);
  const [error, setError] = React.useState<string | null>(null);

  const clearError = React.useCallback(() => {
    setError(null);
  }, []);

  const value = React.useMemo(
    () => ({
      currentMetadata,
      setCurrentMetadata,
      isLoading,
      setIsLoading,
      error,
      setError,
      clearError,
    }),
    [currentMetadata, isLoading, error, clearError]
  );

  return (
    <FormContext.Provider value={value}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </FormContext.Provider>
  );
}

// Hook for managing form submissions
export function useFormSubmission() {
  const { setIsLoading, setError, clearError } = useFormContext();

  const submitForm = React.useCallback(
    async (data: Record<string, any>, metadata: FormMetadata) => {
      setIsLoading(true);
      clearError();

      try {
        console.log('üìã Form Metadata:', metadata);
        console.log('üìù Form Data:', data);

        // ‰ΩøÁî®ÈáçËØïÊú∫Âà∂ÊâßË°åË°®ÂçïÊèê‰∫§
        const result = await RetryHandler.executeWithRetry(
          async () => {
            // ËøôÈáåÂèØ‰ª•Ê∑ªÂä† tRPC Ë∞ÉÁî®
            // await submissionRouter.create({
            //   formId: metadata.id,
            //   data,
            // });

            console.log('‚úÖ Form submitted successfully!');

            // Ê®°Êãü API Ë∞ÉÁî®Âª∂Ëøü
            await new Promise((resolve) => setTimeout(resolve, 1000));

            return { success: true };
          },
          {
            maxAttempts: 3,
            baseDelay: 1000,
            maxDelay: 5000,
            backoffFactor: 2,
            retryableErrors: ['network', 'server', 'timeout']
          },
          (error, attempt) => {
            console.warn(`üîÑ Form submission attempt ${attempt} failed:`, error);
          }
        );

        return result;
      } catch (error) {
        const networkErrorInfo = NetworkErrorAnalyzer.analyze(error);
        setError(networkErrorInfo.message);
        console.error('‚ùå Form submission error:', error);
        return { success: false, error: networkErrorInfo.message };
      } finally {
        setIsLoading(false);
      }
    },
    [setIsLoading, setError, clearError]
  );

  return { submitForm };
}

// Hook for managing form metadata
export function useFormMetadata() {
  const { currentMetadata, setCurrentMetadata, setError } = useFormContext();

  const loadMetadata = React.useCallback(
    async (metadata: FormMetadata) => {
      try {
        setCurrentMetadata(metadata);
        console.log('üìã Form metadata loaded:', metadata);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Âä†ËΩΩË°®ÂçïÈÖçÁΩÆÂ§±Ë¥•';
        setError(errorMessage);
        console.error('‚ùå Failed to load form metadata:', error);
      }
    },
    [setCurrentMetadata, setError]
  );

  const loadMetadataFromJson = React.useCallback(
    async (jsonPath: string) => {
      try {
        // ‰ΩøÁî®ÈáçËØïÊú∫Âà∂Âä†ËΩΩJSONÈÖçÁΩÆ
        const metadata = await RetryHandler.executeWithRetry(
          async () => {
            const response = await fetch(jsonPath);
            if (!response.ok) {
              throw new Error(`Failed to load form configuration: ${response.statusText}`);
            }
            return await response.json();
          },
          {
            maxAttempts: 3,
            baseDelay: 1000,
            maxDelay: 5000,
            backoffFactor: 2,
            retryableErrors: ['network', 'server', 'timeout']
          },
          (error, attempt) => {
            console.warn(`üîÑ JSON loading attempt ${attempt} failed:`, error);
          }
        );

        await loadMetadata(metadata);
      } catch (error) {
        const networkErrorInfo = NetworkErrorAnalyzer.analyze(error);
        setError(networkErrorInfo.message);
        console.error('‚ùå Failed to load JSON metadata:', error);
      }
    },
    [loadMetadata, setError]
  );

  return {
    currentMetadata,
    loadMetadata,
    loadMetadataFromJson,
  };
}